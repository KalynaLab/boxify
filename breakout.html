<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Breakout</title>
        <style>
            * { padding: 0; margin: 0; }
            #breakout { min-width: 600px; max-width: 800px; margin: 0 auto; }
        </style>
        <script src="assets/js/js.cookie.js"></script>
        <script src="assets/js/phaser.v2.11.1.min.js"></script>
        
    </head>
    <body>
        <div id="breakout"></div>
        <script>
            
            function range(start, end) {
                return [...Array((end-start)+1).keys()].map(i => i + start);
            }

            // Javascript set operations
            // https://medium.com/mindorks/implementing-set-operation-in-javascript-2a98b92fc6dc
            function union(setA, setB) {
                var _union = new Set(setA);
                for (var elem of setB) {
                    _union.add(elem);
                }
                return _union;
            }

            function intersection(setA, setB) {
                var _intersection = new Set();
                for (var elem of setA) {
                    if (setB.has(elem)) {
                        _intersection.add(elem);
                    }
                }
                return _intersection;
            }

            function difference(setA, setB) {
                var _difference = new Set(setA);
                for (var elem of setB) {
                    _difference.delete(elem);
                }
                return _difference;
            }

            //var w = window.innerWidth;       
            var w = document.getElementById('breakout').clientWidth;
            
            //console.log(Cookies.getJSON('drawing-data'));
            
            var game = new Phaser.Game(w, w*0.75, Phaser.CANVAS, 'breakout', {
              preload: preload, create: create, update: update
            });
            
            var ball;
            var paddle;
            var brick;
            var newBrick;
            var brickInfo;
            
            var scoreText;
            var score = 0;
            var lives = 3;
            var livesText;
            var lifeLostText;
            var pausedText;
            
            var playing = false;
            var paused = false;
            var lastVelocity;
            
            function preload() {
                game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                game.scale.pageAlignHorizontally = true;
                game.scale.pageAlignVertically = true;
                game.stage.backgroundColor = '#eee';
                game.load.image('ball', 'assets/img/ball.png');
                game.load.spritesheet('ball', 'assets/img/wobble.png', 20, 20);
            }
            function create() {
                game.physics.startSystem(Phaser.Physics.ARCADE);
                //ball = this.game.add.sprite(game.world.width*0.5, game.world.height-25, drawBall(5));
                ball = this.game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
                ball.animations.add('wobble', [0, 1, 0, 2, 0, 1, 0, 2, 0], 24);
                ball.scale.setTo(0.5, 0.5);
                ball.anchor.set(0.5);
                game.physics.enable(ball, Phaser.Physics.ARCADE);
                ball.body.collideWorldBounds = true;
                ball.body.bounce.set(1);
                
                // Game over
                game.physics.arcade.checkCollision.down = false;
                ball.checkWorldBounds = true;
                ball.events.onOutOfBounds.add(ballLeaveScreen, this);
                
                // ADJUST PADDLE WIDTH DYNAMICALLY BASED ON THE WINDOW WIDTH
                paddle = game.add.sprite(game.world.width*0.5, game.world.height-10, drawRect(10, game.world.width*0.10));
                paddle.anchor.set(0.5, 1);
                game.physics.enable(paddle, Phaser.Physics.ARCADE);
                paddle.body.collideWorldBounds = true;
                paddle.body.immovable = true;
                
                //initBricks();
                drawBricks(w, Cookies.getJSON('drawing-data'));
                
                // Score and lives labels
                textStyle = { font: '10px Arial', fill: '#428bca' };
                scoreText = game.add.text(5, 5, 'Points: 0', textStyle);
                livesText = game.add.text(game.world.width-5, 5, 'Lives: '+lives, textStyle);
                livesText.anchor.set(1, 0);
                lifeLostText = game.add.text(game.world.width*0.5, game.world.height*0.5, 'Life lost, press SPACE to continue', textStyle);
                lifeLostText.anchor.set(0.5);
                lifeLostText.visible = false;
                
                pausedText = game.add.text(game.world.width*0.5, game.world.height*0.5, "Game paused, press SPACE to continue", textStyle);
                pausedText.anchor.set(0.5);
                pausedText.visible = false;

                SPACEBAR = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
                SPACEBAR.onDown.add(startPauseGame, this);
                
            }
            function update() {
                game.physics.arcade.collide(ball, paddle, ballHitPaddle);
                game.physics.arcade.collide(ball, bricks, ballHitBrick);
                
                // Mouse controls
                // paddle.x = game.input.x || game.world.width*0.5;
                
                // Left/Right arrow controls
                // http://www.lessmilk.com/tutorial/breakout-phaser
                if (playing) {
                    if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
                        paddle.body.velocity.x = -300;
                    } else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
                        paddle.body.velocity.x = 300;
                    } else {
                        paddle.body.velocity.x = 0;
                    }
                }
            }
            
            // Draw the ball
            function drawBall(radius=10, lineColor=0x000, fillColor=0x428bca) {
                let graphics = game.make.graphics(0, 0);
                //graphics.lineStyle(1, lineColor, 1);
                graphics.beginFill(fillColor, 1);
                graphics.arc(75, 75, radius, 0, Math.PI*2, false);
                graphics.endFill();
                return graphics.generateTexture();
            }
            
            // Draw bricks/paddle
            function drawRect(height, width, lineColor=0x000, fillColor=0x428bca) {
                let graphics = game.make.graphics(0, 0);
                //graphics.lineStyle(1, lineColor, 1);
                graphics.beginFill(fillColor, 1);
                graphics.drawRect(0, 0, width, height);
                graphics.endFill();
                return graphics.generateTexture();
            }
            
            function drawBricks(w, data) {
                
                var transcripts = {},
                    tmpExons = new Set([]);
                for (var t_id in data['transcripts']) {
                    exons = [...Array.from(data['transcripts'][t_id]['exons'].values())];
                    CDS = [...Array.from(data['transcripts'][t_id]['cds'].values())];
                    transcripts[t_id] = {
                        'exons': exons,
                        'cds': CDS,
                        'exonBricks': [...Array.from(exons.values())]
                    }
                    
                    // Subtract the overlapping CDS parts from the exons
                    for (var i = 0; i < CDS.length; i++) {
                        cSet = new Set(range(CDS[i][0], CDS[i][1]));
                        
                        for (var j = 0; j < exons.length; j++) {
                            eSet = new Set(range(exons[j][0], exons[j][1]));
                            
                            // Exon and CDS overlap
                            if (intersection(cSet, eSet).size) {
                                var diff = difference(eSet, cSet);
                                
                                // CHECK FOR THE CASE THAT THE CDS IS INSIDE THE EXON
                                
                                // Exon partly overlaps with the CDS
                                if (diff.size) {
                                    x = Math.min(...Array.from(diff.values()));
                                    y = Math.max(...Array.from(diff.values()));
                                    tmpExons.add(x);
                                    tmpExons.add(y);
                                    transcripts[t_id]['exonBricks'][j] = [x, y];
                                
                                    // Exon is entirely contained in the CDS
                                } else {
                                    transcripts[t_id]['exonBricks'][j] = [];
                                }
                                
                            // No overlap
                            } else {
                                tmpExons.add(exons[j][0]);
                                tmpExons.add(exons[j][1]);
                            }
                        }
                    }
                }
                
                var allExons = [...Array.from(tmpExons.values())];

                // Numerical sort
                //allExons.sort((a, b) => a - b);
                var scale = (w - 100) / (Math.max(...allExons) - Math.min(...allExons)),
                    first = Math.min(...allExons);
                
                // Scale the exon coordinates
                var scaledExons = {};
                for (var i in allExons) {
                    scaledExons[String(allExons[i])] = 50 + Math.round((allExons[i] - first) * scale);
                }
                //console.log(scaledExons);
                
                // Scale the CDS coordinates
                var scaledCDS = {};
                for (var i in data["cdsCoord"]) {
                    scaledCDS[String(data["cdsCoord"][i])] = 50 + Math.round((data["cdsCoord"][i] - first) * scale);
                }
                //console.log(scaledCDS);
                
                bricks = game.add.group();
                var offsetTop = 50,
                    brickHeight = 12,
                    n = 0;
                
                for (var t_id in transcripts) {
                
                    // Draw the exons
                    exons = transcripts[t_id]['exonBricks'];
                    for (var i = 0; i < exons.length; i++) {
                        var brickX1 = scaledExons[String(exons[i][0])],
                            brickX2 = scaledExons[String(exons[i][1])],
                            brickY = offsetTop + (n * 18);
                        
                        // Draw the exon brick
                        newBrick = game.add.sprite(brickX1 + ((brickX2 - brickX1) / 2), brickY + (brickHeight / 2), drawRect(brickHeight, brickX2 - brickX1));
                        newBrick.health = 1;
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                        newBrick.body.immovable = true;
                        newBrick.anchor.set(0.5);
                        bricks.add(newBrick);
                    }
                    
                    
                    // Draw the introns
                    
                    // Draw the CDS
                    cds = transcripts[t_id]['cds'];
                    for (var i = 0; i < cds.length; i++) {
                        var brickX1 = scaledCDS[String(cds[i][0])],
                            brickX2 = scaledCDS[String(cds[i][1])],
                            brickY = offsetTop + (n * 18);
                        
                        // Draw the exon brick
                        newBrick = game.add.sprite(brickX1 + ((brickX2 - brickX1) / 2), brickY + (brickHeight / 2), drawRect(brickHeight, brickX2 - brickX1, lineColor=0x000, fillColor=0x51A351));
                        newBrick.health = 1;
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                        newBrick.body.immovable = true;
                        newBrick.anchor.set(0.5);
                        bricks.add(newBrick);
                    }
                    
                    n++;
                }
                
            }
            
            function ballHitBrick(ball, brick) {
                brick.health -= 1;
                score += 10;
                scoreText.setText('Points: '+score);
                
                if (brick.health == 0) {
                    var killTween = game.add.tween(brick.scale);
                    killTween.to({x:0, y:0}, 200, Phaser.Easing.Linear.None);
                    killTween.onComplete.addOnce(function() {
                        brick.kill();
                    }, this);
                    killTween.start();
                }
                
                // Wait a bit, because the tween needs some time
                // to complete when the last block is destroyed
                game.time.events.add(200, function() {                
                    var count_alive = 0;
                    for (i = 0; i < bricks.children.length; i++) {
                        if (bricks.children[i].health > 0) {
                            count_alive++;
                        }
                    }
                    if (count_alive == 0) {
                        alert('You won!');
                        location.reload();
                    }
                }, this);
            }
            
            function ballLeaveScreen() {
                lives--;
                playing = false;
                
                if (lives) {
                    livesText.setText('Lives: '+lives);
                    lifeLostText.visible = true;
                    ball.reset(game.world.width*0.5, game.world.height-25);
                    paddle.reset(game.world.width*0.5, game.world.height-10);
                    
                    // http://www.html5gamedevs.com/topic/37039-is-there-a-way-to-only-detect-one-key-press/
                    //SPACEBAR = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
                    //SPACEBAR.onDown.add(startPauseGame, this);
                    
                    game.input.onDown.addOnce(startPauseGame, this)
                    
                } else {
                    alert('Game over!');
                    location.reload();
                }
            }
            
            function ballHitPaddle(ball, paddle) {
                ball.animations.play('wobble');
                ball.body.velocity.x = -1.5*5*(paddle.x-ball.x);
            }
            
            function startPauseGame() {             
                lifeLostText.visible = false;
                
                if (paused) {
                    //console.log("RESTART", lastVelocity);
                    ball.body.velocity.set(lastVelocity[0], lastVelocity[1]);
                    paused = false;
                    pausedText.visible = false;
                } else if (playing) {
                    lastVelocity = [ball.body.velocity.x, ball.body.velocity.y];
                    //console.log("PAUSE", lastVelocity);
                    ball.body.velocity.set(0, 0);                
                    paused = true;
                    pausedText.visible = true;
                } else {
                    var randomAngle = Math.floor(Math.random() * (135 - 45) / 5) * 5 + 45;
                    var angleOfFire = Phaser.Math.degToRad(randomAngle);
                    ball.body.velocity.set(350 * Math.cos(angleOfFire), -350 * Math.sin(angleOfFire));
                    console.log(randomAngle, angleOfFire);
                    console.log(ball.body.velocity);
                    playing = true;
                }
            }
            
        </script>
    </body>
</html>