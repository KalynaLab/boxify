<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Breakout</title>
        <style>* { padding: 0; margin: 0; }</style>
        <script src="assets/js/js.cookie.js"></script>
        <script src="assets/js/phaser.v2.11.1.min.js"></script>
        
    </head>
    <body>
        <script>
            var w = window.innerWidth;       
            
            //console.log(Cookies.getJSON('drawing-data'));
            
            var game = new Phaser.Game(w, w*0.5, Phaser.CANVAS, null, {
              preload: preload, create: create, update: update
            });
            
            var ball;
            var paddle;
            var brick;
            var newBrick;
            var brickInfo;
            
            var scoreText;
            var score = 0;
            var lives = 3;
            var livesText;
            var lifeLostText;
            
            var playing = false;
            
            function preload() {
                game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                game.scale.pageAlignHorizontally = true;
                game.scale.pageAlignVertically = true;
                game.stage.backgroundColor = '#eee';
                game.load.image('ball', 'assets/img/ball.png');
                game.load.spritesheet('ball', 'assets/img/wobble.png', 20, 20);
            }
            function create() {
                game.physics.startSystem(Phaser.Physics.ARCADE);
                //ball = this.game.add.sprite(game.world.width*0.5, game.world.height-25, drawBall(5));
                ball = this.game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
                ball.animations.add('wobble', [0, 1, 0, 2, 0, 1, 0, 2, 0], 24);
                ball.scale.setTo(0.5, 0.5);
                ball.anchor.set(0.5);
                game.physics.enable(ball, Phaser.Physics.ARCADE);
                ball.body.collideWorldBounds = true;
                ball.body.bounce.set(1);
                
                // Game over
                game.physics.arcade.checkCollision.down = false;
                ball.checkWorldBounds = true;
                ball.events.onOutOfBounds.add(ballLeaveScreen, this);
                
                // ADJUST PADDLE WIDTH DYNAMICALLY BASED ON THE WINDOW WIDTH
                paddle = game.add.sprite(game.world.width*0.5, game.world.height-10, drawRect(10, 50));
                paddle.anchor.set(0.5, 1);
                game.physics.enable(paddle, Phaser.Physics.ARCADE);
                paddle.body.collideWorldBounds = true;
                paddle.body.immovable = true;
                
                //initBricks();
                drawBricks(w, Cookies.getJSON('drawing-data'));
                
                
                // Score and lives labels
                textStyle = { font: '10px Arial', fill: '#428bca' };
                scoreText = game.add.text(5, 5, 'Points: 0', textStyle);
                livesText = game.add.text(game.world.width-5, 5, 'Lives: '+lives, textStyle);
                livesText.anchor.set(1, 0);
                lifeLostText = game.add.text(game.world.width*0.5, game.world.height*0.5, 'Life lost, press SPACE to continue', textStyle);
                lifeLostText.anchor.set(0.5);
                lifeLostText.visible = false;
                
                SPACEBAR = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
                SPACEBAR.onDown.addOnce(startGame, this);
                
                // ADD PAUSE STATE
                
            }
            function update() {
                game.physics.arcade.collide(ball, paddle, ballHitPaddle);
                game.physics.arcade.collide(ball, bricks, ballHitBrick);
                
                // Mouse controls
                // paddle.x = game.input.x || game.world.width*0.5;
                
                // Left/Right arrow controls
                // http://www.lessmilk.com/tutorial/breakout-phaser
                if (playing) {
                    if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
                        paddle.body.velocity.x = -300;
                    } else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
                        paddle.body.velocity.x = 300;
                    } else {
                        paddle.body.velocity.x = 0;
                    }
                }
            }
            
            // Draw the ball
            function drawBall(radius=10, lineColor=0x000, fillColor=0x428bca) {
                let graphics = game.make.graphics(0, 0);
                //graphics.lineStyle(1, lineColor, 1);
                graphics.beginFill(fillColor, 1);
                graphics.arc(75, 75, radius, 0, Math.PI*2, false);
                graphics.endFill();
                return graphics.generateTexture();
            }
            
            // Draw bricks/paddle
            function drawRect(height, width, lineColor=0x000, fillColor=0x428bca) {
                let graphics = game.make.graphics(0, 0);
                //graphics.lineStyle(1, lineColor, 1);
                graphics.beginFill(fillColor, 1);
                graphics.drawRect(0, 0, width, height);
                graphics.endFill();
                return graphics.generateTexture();
            }
            
            function drawBricks(w, data) {
                
                var scale = (w - 100) / (data["exonCoord"][data["exonCoord"].length - 1] - data["exonCoord"][0]),
                    first = data["exonCoord"][0],
                    scaledExonCoord = {},
                    scaledCdsCoord = {},
                    transcripts = Object.keys(data["transcripts"]);
                
                console.log(w);
                console.log(scale, first);
                console.log(data);
                
                // Scale the coordinates
                for (var i in data["exonCoord"]) {
                    scaledExonCoord[String(data["exonCoord"][i])] = 50 + Math.round((data["exonCoord"][i]-first) * scale);
                }
                
                // Scale the CDS coordinates
                for (var i in data["cdsCoord"]) {
                    scaledCdsCoord[String(data["cdsCoord"][i])] = 50 + Math.round((data["cdsCoord"][i]-first) * scale);
                    console.log(data["cdsCoord"][i], first, data["cdsCoord"][i] - first);
                }
                
                bricks = game.add.group();
                var offsetTop = 50,
                    brickHeight = 12;
                
                // Draw the exons
                var endOfLastExon = 0;
                for (var i = 0; i < transcripts.length; i++) {
                    var t_id = transcripts[i],
                        coordX = data["transcripts"][t_id]["exons"];
                    for (var j in coordX) {
                        var brickX = scaledExonCoord[String(coordX[j][0])],
                            brickY = offsetTop + (i * 18),
                            end = scaledExonCoord[String(coordX[j][1])];
                        
                        // Draw exon
                        newBrick = game.add.sprite(brickX+((end-brickX)/2), brickY+(brickHeight/2), drawRect(brickHeight, end - brickX));
                        newBrick.health = 1;
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                        newBrick.body.immovable = true;
                        newBrick.anchor.set(0.5);
                        bricks.add(newBrick);
                        
                        // Draw intron
                        if (j > 0 && j < coordX.length) {
                            newBrick = game.add.sprite(brickX+((endOfLastExon-brickX)/2), brickY+(brickHeight/2), drawRect(2, endOfLastExon - brickX, 0x000, 0x000));
                            newBrick.health = 1;
                            game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                            newBrick.body.immovable = true;
                            newBrick.anchor.set(0.5);
                            bricks.add(newBrick);
                        }
                        
                        endOfLastExon = end;
                    }
                }
                
                // Draw the CDS
                for (var i = 0; i < transcripts.length; i++) {
                    var t_id = transcripts[i],
                        coordX = data["transcripts"][t_id]["cds"];
                    for (var j in coordX) {
                        var brickX = scaledCdsCoord[String(coordX[j][0])],
                            brickY = offsetTop + (i*18),
                            end = scaledCdsCoord[String(coordX[j][1])];

                        newBrick = game.add.sprite(brickX+((end-brickX)/2), brickY+(brickHeight/2), drawRect(brickHeight, end - brickX, lineColor=0x000, fillColor=0x51A351));
                        newBrick.health = 1;
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                        newBrick.body.immovable = true;
                        newBrick.anchor.set(0.5);
                        bricks.add(newBrick);
                    }
                }
            }
            
            function initBricks() {
                brickInfo = {
                    width: 50,
                    height: 20,
                    count: {
                        row: 3,
                        col: 7
                    },
                    offset: { 
                        top: 50,
                        left: 60
                    },
                    padding: 10
                };
                bricks = game.add.group();
                for (c=0; c < brickInfo.count.col; c++) {
                    for (r=0; r < brickInfo.count.row; r++) {
                        var brickX = (c*(brickInfo.width+brickInfo.padding))+brickInfo.offset.left;
                        var brickY = (r*(brickInfo.height+brickInfo.padding))+brickInfo.offset.top;
                        newBrick = game.add.sprite(brickX, brickY, drawRect(brickInfo.height, brickInfo.width));
                        newBrick.health = 1;
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE);
                        newBrick.body.immovable = true;
                        newBrick.anchor.set(0.5);
                        bricks.add(newBrick);
                    }
                }
            }
            
            function ballHitBrick(ball, brick) {
                brick.health -= 1;
                score += 10;
                scoreText.setText('Points: '+score);
                
                if (brick.health == 0) {
                    var killTween = game.add.tween(brick.scale);
                    killTween.to({x:0, y:0}, 200, Phaser.Easing.Linear.None);
                    killTween.onComplete.addOnce(function() {
                        brick.kill();
                    }, this);
                    killTween.start();
                }
                
                // Wait a bit, because the tween needs some time
                // to complete when the last block is destroyed
                game.time.events.add(200, function() {                
                    var count_alive = 0;
                    for (i = 0; i < bricks.children.length; i++) {
                        if (bricks.children[i].health > 0) {
                            count_alive++;
                        }
                    }
                    if (count_alive == 0) {
                        alert('You won!');
                        location.reload();
                    }
                }, this);
            }
            
            function ballLeaveScreen() {
                lives--;
                playing = false;
                
                if (lives) {
                    livesText.setText('Lives: '+lives);
                    lifeLostText.visible = true;
                    ball.reset(game.world.width*0.5, game.world.height-25);
                    paddle.reset(game.world.width*0.5, game.world.height-10);
                    
                    // http://www.html5gamedevs.com/topic/37039-is-there-a-way-to-only-detect-one-key-press/
                    SPACEBAR = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
                    SPACEBAR.onDown.addOnce(startGame, this);
                    
                    game.input.onDown.addOnce(startGame, this)
                    
                } else {
                    alert('Game over!');
                    location.reload();
                }
            }
            
            function ballHitPaddle(ball, paddle) {
                ball.animations.play('wobble');
                ball.body.velocity.x = -1.5*5*(paddle.x-ball.x);
            }
            
            function startGame() {                
                lifeLostText.visible = false;
                ball.body.velocity.set(150, -150);
                
                var randomAngle = Math.floor(Math.random() * (135 - 45) / 5) * 5 + 45;
                var angleOfFire = Phaser.Math.degToRad(randomAngle);
                console.log(randomAngle, angleOfFire);
                ball.body.velocity.set(250 * Math.cos(angleOfFire), -250 * Math.sin(angleOfFire));
                console.log(ball.body.velocity);
                playing = true
            }
            
        </script>
    </body>
</html>